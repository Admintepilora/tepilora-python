"""
Securities API namespace.

AUTO-GENERATED by scripts/generate_sdk.py - DO NOT EDIT MANUALLY!
Regenerate with: python scripts/generate_sdk.py --category securities
"""
from __future__ import annotations

from typing import Any, Dict, List, Optional, Union

from ._base import AsyncBaseAPI, BaseAPI


class SecuritiesAPI(BaseAPI):
    """Securities namespace: breakdowns, description, details, facets, fees, filter, history, lookup, mifid, rels, screen, search."""

    def breakdowns(
        self,
        *,
        identifiers: Union[str, List[str]],
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
    ) -> Any:
        """Get portfolio breakdowns

        Sector, country, asset class breakdowns for funds/ETFs.

        Args:
        identifiers: List of TepiloraCodes"""
        params: Dict[str, Any] = {}
        params["identifiers"] = identifiers
        return self._call("securities.breakdowns", params=params, options=options, context=context)

    def description(
        self,
        *,
        identifier: Optional[str] = None,
        identifiers: Optional[Union[str, List[str]]] = None,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Get security description

        Full metadata for one or more securities.

        Args:
        identifier: Single identifier
        identifiers: Multiple identifiers"""
        params: Dict[str, Any] = {}
        if identifier is not None:
            params["identifier"] = identifier
        if identifiers is not None:
            params["identifiers"] = identifiers
        return self._call("securities.description", params=params, options=options, context=context, response_format=response_format)

    def details(
        self,
        *,
        identifier: Optional[str] = None,
        identifiers: Optional[Union[str, List[str]]] = None,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Get security details

        Alias for description. Full metadata for one or more securities.

        Args:
        identifier: Single identifier
        identifiers: Multiple identifiers"""
        params: Dict[str, Any] = {}
        if identifier is not None:
            params["identifier"] = identifier
        if identifiers is not None:
            params["identifiers"] = identifiers
        return self._call("securities.details", params=params, options=options, context=context, response_format=response_format)

    def facets(
        self,
        *,
        fields: List[Any],
        filters: Optional[Dict[str, Any]] = None,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
    ) -> Any:
        """Get facets

        Aggregated field values for building filters.

        Args:
        fields: Fields to aggregate
        filters: Pre-filter"""
        params: Dict[str, Any] = {}
        params["fields"] = fields
        if filters is not None:
            params["filters"] = filters
        return self._call("securities.facets", params=params, options=options, context=context)

    def fees(
        self,
        *,
        identifiers: Union[str, List[str]],
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Get fee data

        TER, ongoing charges, and fee breakdown.

        Args:
        identifiers: List of TepiloraCodes"""
        params: Dict[str, Any] = {}
        params["identifiers"] = identifiers
        return self._call("securities.fees", params=params, options=options, context=context, response_format=response_format)

    def filter(
        self,
        *,
        filters: Dict[str, Any],
        limit: Optional[int] = 50,
        offset: Optional[int] = 0,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Filter securities

        Filter by field values without text search.

        Args:
        filters: Field filters
        limit: Maximum results
        offset: Pagination offset"""
        params: Dict[str, Any] = {}
        params["filters"] = filters
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        return self._call("securities.filter", params=params, options=options, context=context, response_format=response_format)

    def history(
        self,
        *,
        identifiers: Union[str, List[str]],
        start_date: Optional[str] = None,
        end_date: Optional[str] = None,
        limit: Optional[int] = 5000,
        pivot: Optional[bool] = False,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Get price history

        Historical prices for securities. Requires TepiloraCode(s).

        Args:
        identifiers: List of TepiloraCodes
        start_date: Start date (YYYY-MM-DD)
        end_date: End date (YYYY-MM-DD)
        limit: Maximum results
        pivot: Pivot format (dates as rows, TCs as columns)"""
        params: Dict[str, Any] = {}
        params["identifiers"] = identifiers
        if start_date is not None:
            params["start_date"] = start_date
        if end_date is not None:
            params["end_date"] = end_date
        if limit is not None:
            params["limit"] = limit
        if pivot is not None:
            params["pivot"] = pivot
        return self._call("securities.history", params=params, options=options, context=context, response_format=response_format)

    def lookup(
        self,
        *,
        identifier: str,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
    ) -> Any:
        """Lookup security by identifier

        Direct lookup by ISIN, TepiloraCode, or ticker.

        Args:
        identifier: TepiloraCode or ISIN"""
        params: Dict[str, Any] = {}
        params["identifier"] = identifier
        return self._call("securities.lookup", params=params, options=options, context=context)

    def mifid(
        self,
        *,
        identifiers: Union[str, List[str]],
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Get MiFID II data

        MiFID II classification and risk data.

        Args:
        identifiers: List of TepiloraCodes"""
        params: Dict[str, Any] = {}
        params["identifiers"] = identifiers
        return self._call("securities.mifid", params=params, options=options, context=context, response_format=response_format)

    def rels(
        self,
        *,
        identifier: str,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Get related securities

        Related securities (same index, same issuer, etc.).

        Args:
        identifier: TepiloraCode or ISIN"""
        params: Dict[str, Any] = {}
        params["identifier"] = identifier
        return self._call("securities.rels", params=params, options=options, context=context, response_format=response_format)

    def screen(
        self,
        *,
        universe: Optional[Dict[str, Any]] = None,
        query_name: Optional[str] = None,
        criteria: Optional[Dict[str, Any]] = None,
        rank_by: Optional[str] = None,
        limit: Optional[int] = 50,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Screen securities

        Batch screening by analytics metrics.

        Args:
        universe: Universe filters
        query_name: Saved query name
        criteria: Metric criteria
        rank_by: Ranking metric
        limit: Maximum results"""
        params: Dict[str, Any] = {}
        if universe is not None:
            params["universe"] = universe
        if query_name is not None:
            params["query_name"] = query_name
        if criteria is not None:
            params["criteria"] = criteria
        if rank_by is not None:
            params["rank_by"] = rank_by
        if limit is not None:
            params["limit"] = limit
        return self._call("securities.screen", params=params, options=options, context=context, response_format=response_format)

    def search(
        self,
        *,
        query: Optional[str] = "",
        filters: Optional[Dict[str, Any]] = None,
        limit: Optional[int] = 50,
        offset: Optional[int] = 0,
        include_facets: Optional[bool] = False,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Search securities

        Full-text search with filters and facets.

        Args:
        query: Search query
        filters: Field filters
        limit: Maximum results
        offset: Pagination offset
        include_facets: Include aggregations"""
        params: Dict[str, Any] = {}
        if query is not None:
            params["query"] = query
        if filters is not None:
            params["filters"] = filters
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if include_facets is not None:
            params["include_facets"] = include_facets
        return self._call("securities.search", params=params, options=options, context=context, response_format=response_format)



class AsyncSecuritiesAPI(AsyncBaseAPI):
    """Securities namespace: breakdowns, description, details, facets, fees, filter, history, lookup, mifid, rels, screen, search."""

    async def breakdowns(
        self,
        *,
        identifiers: Union[str, List[str]],
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
    ) -> Any:
        """Get portfolio breakdowns

        Sector, country, asset class breakdowns for funds/ETFs.

        Args:
        identifiers: List of TepiloraCodes"""
        params: Dict[str, Any] = {}
        params["identifiers"] = identifiers
        return await self._call("securities.breakdowns", params=params, options=options, context=context)

    async def description(
        self,
        *,
        identifier: Optional[str] = None,
        identifiers: Optional[Union[str, List[str]]] = None,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Get security description

        Full metadata for one or more securities.

        Args:
        identifier: Single identifier
        identifiers: Multiple identifiers"""
        params: Dict[str, Any] = {}
        if identifier is not None:
            params["identifier"] = identifier
        if identifiers is not None:
            params["identifiers"] = identifiers
        return await self._call("securities.description", params=params, options=options, context=context, response_format=response_format)

    async def details(
        self,
        *,
        identifier: Optional[str] = None,
        identifiers: Optional[Union[str, List[str]]] = None,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Get security details

        Alias for description. Full metadata for one or more securities.

        Args:
        identifier: Single identifier
        identifiers: Multiple identifiers"""
        params: Dict[str, Any] = {}
        if identifier is not None:
            params["identifier"] = identifier
        if identifiers is not None:
            params["identifiers"] = identifiers
        return await self._call("securities.details", params=params, options=options, context=context, response_format=response_format)

    async def facets(
        self,
        *,
        fields: List[Any],
        filters: Optional[Dict[str, Any]] = None,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
    ) -> Any:
        """Get facets

        Aggregated field values for building filters.

        Args:
        fields: Fields to aggregate
        filters: Pre-filter"""
        params: Dict[str, Any] = {}
        params["fields"] = fields
        if filters is not None:
            params["filters"] = filters
        return await self._call("securities.facets", params=params, options=options, context=context)

    async def fees(
        self,
        *,
        identifiers: Union[str, List[str]],
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Get fee data

        TER, ongoing charges, and fee breakdown.

        Args:
        identifiers: List of TepiloraCodes"""
        params: Dict[str, Any] = {}
        params["identifiers"] = identifiers
        return await self._call("securities.fees", params=params, options=options, context=context, response_format=response_format)

    async def filter(
        self,
        *,
        filters: Dict[str, Any],
        limit: Optional[int] = 50,
        offset: Optional[int] = 0,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Filter securities

        Filter by field values without text search.

        Args:
        filters: Field filters
        limit: Maximum results
        offset: Pagination offset"""
        params: Dict[str, Any] = {}
        params["filters"] = filters
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        return await self._call("securities.filter", params=params, options=options, context=context, response_format=response_format)

    async def history(
        self,
        *,
        identifiers: Union[str, List[str]],
        start_date: Optional[str] = None,
        end_date: Optional[str] = None,
        limit: Optional[int] = 5000,
        pivot: Optional[bool] = False,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Get price history

        Historical prices for securities. Requires TepiloraCode(s).

        Args:
        identifiers: List of TepiloraCodes
        start_date: Start date (YYYY-MM-DD)
        end_date: End date (YYYY-MM-DD)
        limit: Maximum results
        pivot: Pivot format (dates as rows, TCs as columns)"""
        params: Dict[str, Any] = {}
        params["identifiers"] = identifiers
        if start_date is not None:
            params["start_date"] = start_date
        if end_date is not None:
            params["end_date"] = end_date
        if limit is not None:
            params["limit"] = limit
        if pivot is not None:
            params["pivot"] = pivot
        return await self._call("securities.history", params=params, options=options, context=context, response_format=response_format)

    async def lookup(
        self,
        *,
        identifier: str,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
    ) -> Any:
        """Lookup security by identifier

        Direct lookup by ISIN, TepiloraCode, or ticker.

        Args:
        identifier: TepiloraCode or ISIN"""
        params: Dict[str, Any] = {}
        params["identifier"] = identifier
        return await self._call("securities.lookup", params=params, options=options, context=context)

    async def mifid(
        self,
        *,
        identifiers: Union[str, List[str]],
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Get MiFID II data

        MiFID II classification and risk data.

        Args:
        identifiers: List of TepiloraCodes"""
        params: Dict[str, Any] = {}
        params["identifiers"] = identifiers
        return await self._call("securities.mifid", params=params, options=options, context=context, response_format=response_format)

    async def rels(
        self,
        *,
        identifier: str,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Get related securities

        Related securities (same index, same issuer, etc.).

        Args:
        identifier: TepiloraCode or ISIN"""
        params: Dict[str, Any] = {}
        params["identifier"] = identifier
        return await self._call("securities.rels", params=params, options=options, context=context, response_format=response_format)

    async def screen(
        self,
        *,
        universe: Optional[Dict[str, Any]] = None,
        query_name: Optional[str] = None,
        criteria: Optional[Dict[str, Any]] = None,
        rank_by: Optional[str] = None,
        limit: Optional[int] = 50,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Screen securities

        Batch screening by analytics metrics.

        Args:
        universe: Universe filters
        query_name: Saved query name
        criteria: Metric criteria
        rank_by: Ranking metric
        limit: Maximum results"""
        params: Dict[str, Any] = {}
        if universe is not None:
            params["universe"] = universe
        if query_name is not None:
            params["query_name"] = query_name
        if criteria is not None:
            params["criteria"] = criteria
        if rank_by is not None:
            params["rank_by"] = rank_by
        if limit is not None:
            params["limit"] = limit
        return await self._call("securities.screen", params=params, options=options, context=context, response_format=response_format)

    async def search(
        self,
        *,
        query: Optional[str] = "",
        filters: Optional[Dict[str, Any]] = None,
        limit: Optional[int] = 50,
        offset: Optional[int] = 0,
        include_facets: Optional[bool] = False,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Search securities

        Full-text search with filters and facets.

        Args:
        query: Search query
        filters: Field filters
        limit: Maximum results
        offset: Pagination offset
        include_facets: Include aggregations"""
        params: Dict[str, Any] = {}
        if query is not None:
            params["query"] = query
        if filters is not None:
            params["filters"] = filters
        if limit is not None:
            params["limit"] = limit
        if offset is not None:
            params["offset"] = offset
        if include_facets is not None:
            params["include_facets"] = include_facets
        return await self._call("securities.search", params=params, options=options, context=context, response_format=response_format)


