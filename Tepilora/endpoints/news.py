"""
News API namespace.

AUTO-GENERATED by scripts/generate_sdk.py - DO NOT EDIT MANUALLY!
Regenerate with: python scripts/generate_sdk.py --category news
"""
from __future__ import annotations

from typing import Any, Dict, List, Optional

from ._base import AsyncBaseAPI, BaseAPI


class NewsAPI(BaseAPI):
    """News namespace: details, facets, latest, search, trending, trending_compare, trending_history."""

    def details(
        self,
        *,
        url: str,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
    ) -> Any:
        """Get article details

        Full article content by URL.

        Args:
        url: Article URL"""
        params: Dict[str, Any] = {}
        params["url"] = url
        return self._call("news.details", params=params, options=options, context=context)

    def facets(
        self,
        *,
        filters: Optional[Dict[str, Any]] = None,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
    ) -> Any:
        """Get news facets

        Available sources and topics.

        Args:
        filters: Pre-filter"""
        params: Dict[str, Any] = {}
        if filters is not None:
            params["filters"] = filters
        return self._call("news.facets", params=params, options=options, context=context)

    def latest(
        self,
        *,
        limit: Optional[int] = 20,
        filters: Optional[Dict[str, Any]] = None,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Get latest news

        Most recent articles.

        Args:
        limit: Maximum results
        filters: Source/topic filters"""
        params: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if filters is not None:
            params["filters"] = filters
        return self._call("news.latest", params=params, options=options, context=context, response_format=response_format)

    def search(
        self,
        *,
        query: str,
        limit: Optional[int] = 20,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None,
        filters: Optional[Dict[str, Any]] = None,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Search news articles

        Full-text search in news articles.

        Args:
        query: Search query. Multi-word queries use OR logic (e.g. 'inflation eurozone' matches articles containing either word). Use quotes for exact phrase.
        limit: Maximum results
        start_date: Start date (YYYY-MM-DD)
        end_date: End date (YYYY-MM-DD)
        filters: Source/topic filters"""
        params: Dict[str, Any] = {}
        params["query"] = query
        if limit is not None:
            params["limit"] = limit
        if start_date is not None:
            params["start_date"] = start_date
        if end_date is not None:
            params["end_date"] = end_date
        if filters is not None:
            params["filters"] = filters
        return self._call("news.search", params=params, options=options, context=context, response_format=response_format)

    def trending(
        self,
        *,
        limit: Optional[int] = 50,
        term_type: Optional[str] = "all",
        finance_only: Optional[bool] = False,
        min_velocity: Optional[float] = None,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Get trending terms

        Currently trending topics and entities.

        Args:
        limit: Maximum results
        term_type: all|entity|keyword
        finance_only: Finance terms only
        min_velocity: Minimum velocity threshold"""
        params: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if term_type is not None:
            params["term_type"] = term_type
        if finance_only is not None:
            params["finance_only"] = finance_only
        if min_velocity is not None:
            params["min_velocity"] = min_velocity
        return self._call("news.trending", params=params, options=options, context=context, response_format=response_format)

    def trending_compare(
        self,
        *,
        terms: List[Any],
        start_date: Optional[str] = None,
        end_date: Optional[str] = None,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Compare trending terms

        Compare multiple terms over time.

        Args:
        terms: Terms to compare
        start_date: Start date (YYYY-MM-DD)
        end_date: End date (YYYY-MM-DD)"""
        params: Dict[str, Any] = {}
        params["terms"] = terms
        if start_date is not None:
            params["start_date"] = start_date
        if end_date is not None:
            params["end_date"] = end_date
        return self._call("news.trending_compare", params=params, options=options, context=context, response_format=response_format)

    def trending_history(
        self,
        *,
        term: str,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Get trending history

        Historical trending data for a term.

        Args:
        term: Term to track
        start_date: Start date (YYYY-MM-DD)
        end_date: End date (YYYY-MM-DD)"""
        params: Dict[str, Any] = {}
        params["term"] = term
        if start_date is not None:
            params["start_date"] = start_date
        if end_date is not None:
            params["end_date"] = end_date
        return self._call("news.trending_history", params=params, options=options, context=context, response_format=response_format)



class AsyncNewsAPI(AsyncBaseAPI):
    """News namespace: details, facets, latest, search, trending, trending_compare, trending_history."""

    async def details(
        self,
        *,
        url: str,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
    ) -> Any:
        """Get article details

        Full article content by URL.

        Args:
        url: Article URL"""
        params: Dict[str, Any] = {}
        params["url"] = url
        return await self._call("news.details", params=params, options=options, context=context)

    async def facets(
        self,
        *,
        filters: Optional[Dict[str, Any]] = None,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
    ) -> Any:
        """Get news facets

        Available sources and topics.

        Args:
        filters: Pre-filter"""
        params: Dict[str, Any] = {}
        if filters is not None:
            params["filters"] = filters
        return await self._call("news.facets", params=params, options=options, context=context)

    async def latest(
        self,
        *,
        limit: Optional[int] = 20,
        filters: Optional[Dict[str, Any]] = None,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Get latest news

        Most recent articles.

        Args:
        limit: Maximum results
        filters: Source/topic filters"""
        params: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if filters is not None:
            params["filters"] = filters
        return await self._call("news.latest", params=params, options=options, context=context, response_format=response_format)

    async def search(
        self,
        *,
        query: str,
        limit: Optional[int] = 20,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None,
        filters: Optional[Dict[str, Any]] = None,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Search news articles

        Full-text search in news articles.

        Args:
        query: Search query. Multi-word queries use OR logic (e.g. 'inflation eurozone' matches articles containing either word). Use quotes for exact phrase.
        limit: Maximum results
        start_date: Start date (YYYY-MM-DD)
        end_date: End date (YYYY-MM-DD)
        filters: Source/topic filters"""
        params: Dict[str, Any] = {}
        params["query"] = query
        if limit is not None:
            params["limit"] = limit
        if start_date is not None:
            params["start_date"] = start_date
        if end_date is not None:
            params["end_date"] = end_date
        if filters is not None:
            params["filters"] = filters
        return await self._call("news.search", params=params, options=options, context=context, response_format=response_format)

    async def trending(
        self,
        *,
        limit: Optional[int] = 50,
        term_type: Optional[str] = "all",
        finance_only: Optional[bool] = False,
        min_velocity: Optional[float] = None,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Get trending terms

        Currently trending topics and entities.

        Args:
        limit: Maximum results
        term_type: all|entity|keyword
        finance_only: Finance terms only
        min_velocity: Minimum velocity threshold"""
        params: Dict[str, Any] = {}
        if limit is not None:
            params["limit"] = limit
        if term_type is not None:
            params["term_type"] = term_type
        if finance_only is not None:
            params["finance_only"] = finance_only
        if min_velocity is not None:
            params["min_velocity"] = min_velocity
        return await self._call("news.trending", params=params, options=options, context=context, response_format=response_format)

    async def trending_compare(
        self,
        *,
        terms: List[Any],
        start_date: Optional[str] = None,
        end_date: Optional[str] = None,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Compare trending terms

        Compare multiple terms over time.

        Args:
        terms: Terms to compare
        start_date: Start date (YYYY-MM-DD)
        end_date: End date (YYYY-MM-DD)"""
        params: Dict[str, Any] = {}
        params["terms"] = terms
        if start_date is not None:
            params["start_date"] = start_date
        if end_date is not None:
            params["end_date"] = end_date
        return await self._call("news.trending_compare", params=params, options=options, context=context, response_format=response_format)

    async def trending_history(
        self,
        *,
        term: str,
        start_date: Optional[str] = None,
        end_date: Optional[str] = None,
        options: Optional[Dict[str, Any]] = None,
        context: Optional[Dict[str, Any]] = None,
        response_format: Optional[str] = None,
    ) -> Any:
        """Get trending history

        Historical trending data for a term.

        Args:
        term: Term to track
        start_date: Start date (YYYY-MM-DD)
        end_date: End date (YYYY-MM-DD)"""
        params: Dict[str, Any] = {}
        params["term"] = term
        if start_date is not None:
            params["start_date"] = start_date
        if end_date is not None:
            params["end_date"] = end_date
        return await self._call("news.trending_history", params=params, options=options, context=context, response_format=response_format)


